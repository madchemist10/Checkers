package gameplay;

import board.BoardSquare;
import board.CheckerBoard;
import board.SquareState;
import checker.Checker;
import checker.ClickedState;
import checker.Color;
import checker.Piece;
import computer.ComputerPlayer;
import constants.Constants;
import gui.StatusPanel;

import javax.swing.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.List;

/**
 * Maintains the map of checkers in play, as well as
 * the layout of the checkerboard and the positions
 * of all checker pieces.
 */
public class CheckerGame implements PropertyChangeListener{

    /**Map that contains all checker pieces.
     * Key is a unique identifier of COLOR_checkerID*/
    private final Map<String,Checker> checkerMap;

    /**Unique identifier for each checker piece.*/
    private static int checkerID = 0;

    /**Checker playing board, where pieces will be located.*/
    private final CheckerBoard checkerBoard;

    /**Flag to alert everyone there is a jump involved in a move.*/
    private boolean jumpInvolved = false;

    /**Maintain the current player's turn color.*/
    private static Color PLAYER_TURN = Color.WHITE;

    /**Reference to the computer player.*/
    private final ComputerPlayer computerPlayer;

    private final StatusPanel statusPanel;

    /**Flag to turn Computer player on and off.*/
    private static boolean AI = false;

    /**
     * Constructor to create the checker pieces and the game board.
     */
    public CheckerGame(StatusPanel statusPanel){
        this.statusPanel = statusPanel;
        this.checkerMap = new HashMap<>();
        generateCheckerPieces();
        this.checkerBoard = new CheckerBoard();
        generateCheckerBoard();
        this.checkerBoard.setVisible(true);
        this.statusPanel.updateWinnerLabel(Constants.CURRENT_TURN+CheckerGame.PLAYER_TURN);
        /*Generate the computer player if AI is turned on.*/
        this.computerPlayer = new ComputerPlayer(randomComputerPlayerColor(),this);
        if(AI){
            allowComputerMove();
        }
    }

    /**
     * Handle property change events that could be received
     * from either BoardSquares or Checker pieces.
     * @param evt event that has been generated by clicks
     *            on either BoardSquares of Checker pieces.
     */
    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        SwingUtilities.invokeLater(new PropertyChangeHandler(this,evt));
    }

    /**
     * Must be run on the GUI thread, Handle the
     * Property change events that are generated throughout
     * the system.
     * Assign possible moves as well as move checker
     * pieces from one square to another.
     */
    private static class PropertyChangeHandler implements Runnable{
        private final WeakReference<CheckerGame> wGame;
        private final PropertyChangeEvent evt;

        PropertyChangeHandler(CheckerGame game, PropertyChangeEvent evt){
            this.wGame = new WeakReference<>(game);
            this.evt = evt;
        }
        @Override
        public void run() {
            CheckerGame checkerGame = this.wGame.get();
            if(checkerGame == null){
                return;
            }
            String eventName = evt.getPropertyName();
            switch(eventName){
                /*A square has been clicked.*/
                case Constants.SQUARE_CLICKED:
                    BoardSquare boardSquare = (BoardSquare) evt.getSource();
                    ClickedState squareClickedState = (ClickedState) evt.getNewValue();
                    switch(squareClickedState){
                        case CLICKED:
                            checkerGame.moveSelectedChecker(boardSquare);
                            break;
                        case NOT_CLICKED:
                            break;
                    }
                    break;
                /*A checker has been selected.*/
                case Constants.CHECKER_CLICKED:
                    Checker checker = (Checker) evt.getSource();
                    /*Execute checker moves only if it is the correct color.*/
                    if(!checker.getCheckerColor().equals(CheckerGame.PLAYER_TURN)) {
                        break;
                    }
                    ClickedState checkerClickedState = (ClickedState) evt.getNewValue();
                    switch(checkerClickedState){
                        case CLICKED:
                            checkerGame.assignPossibleMoves(checker);
                            checkerGame.setAllCheckersToNotChecked(checker);
                            break;
                        case NOT_CLICKED:
                            checkerGame.getCheckerBoard().resetBoardSquares();
                            break;
                    }
                    break;
                case Constants.RESET_BOARD:
                    Checker currentChecker = null;
                    if(evt.getNewValue() != null){
                        currentChecker = (Checker) evt.getNewValue();
                    }
                    checkerGame.setAllCheckersToNotChecked(currentChecker);
                    checkerGame.getCheckerBoard().resetBoardSquares();
                    break;
            }
        }
    }

    /**
     * Assign all possible moves (Normal and Jumps) to be visible
     * with colors of:
     *  GREEN (Jump)
     *  ORANGE (Normal).
     * @param checker Checker to assign moves to.
     */
    public void assignPossibleMoves(Checker checker){
        /*Assign all possible jumps the color of green squares.*/
        ArrayList<BoardSquare> jumpsAvailable = jumpAvailable(checker);
        for(BoardSquare boardSquare : jumpsAvailable){
            if(boardSquare != null){
                boardSquare.setSquareColor(Color.GREEN);
            }
        }
        /*Assign all possible moves the color of orange squares*/
        ArrayList<BoardSquare> movesAvailable = moveAvailable(checker);
        for(BoardSquare boardSquare : movesAvailable){
            if(boardSquare != null){
                boardSquare.setSquareColor(Color.ORANGE);
            }
        }
    }

    /**
     * Execute a computer player move on separate thread.
     */
    private static class ComputerPlayerMove implements Runnable{
        private final WeakReference<ComputerPlayer> wComputerPlayer;

        ComputerPlayerMove(ComputerPlayer computerPlayer){
            this.wComputerPlayer = new WeakReference<>(computerPlayer);
        }

        @Override
        public void run() {
            ComputerPlayer computerPlayer = this.wComputerPlayer.get();
            if(computerPlayer == null){
                return;
            }
            System.out.println("\nComputer is thinking.....");
            computerPlayer.makeMove();
            System.out.println("Computer has made his move...");
        }
    }

    /**
     * Choose a random player color.
     * @return Color chosen at random.
     */
    private static Color randomComputerPlayerColor(){
        Random randomGenerator = new Random(System.currentTimeMillis());
        int random = randomGenerator.nextInt()%2;   //ensure number is 0 or 1
        switch(random){
            case 0:
                return Color.WHITE;
            case 1:
                return Color.BLACK;
            default:
                return Color.WHITE; //should never be reached.
        }
    }

    public StatusPanel getStatusPanel(){
        return this.statusPanel;
    }

    /**
     * Retrieve the map of checker ids to checker pieces.
     * @return checker map.
     */
    public Map<String,Checker> getCheckerMap(){
        return this.checkerMap;
    }

    /**
     * Retrieve the checker board where all the squares
     * and checker pieces lie.
     * @return the checkerboard for this checker game.
     */
    public CheckerBoard getCheckerBoard(){
        return this.checkerBoard;
    }

    /**
     * Create the checker board.
     * Place the pieces on the checker board.
     * Set the correct locations and states of all the checkers.
     */
    private void generateCheckerBoard(){
        addSquaresToBoard();
        setUpCheckerBoard();
    }

    /**
     * Create and store the two sets of checker pieces.
     */
    private void generateCheckerPieces(){
        createBlackCheckers();
        createWhiteCheckers();
    }

    /**
     * Create all 12 black checker pieces.
     * Place the 12 black checker pieces in the checkerMap.
     */
    private void createBlackCheckers(){
        List<Checker> blackCheckers = createCheckerSet(Color.BLACK);
        for(Checker checker: blackCheckers){
            this.checkerMap.put(checker.getCheckerID(), checker);
            checker.setCheckerGame(this);
        }
    }

    /**
     * Create all 12 white checker pieces.
     * Place the 12 white checker pieces in the checkerMap.
     */
    private void createWhiteCheckers(){
        List<Checker> whiteCheckers = createCheckerSet(Color.WHITE);
        for(Checker checker: whiteCheckers){
            this.checkerMap.put(checker.getCheckerID(), checker);
            checker.setCheckerGame(this);
        }
    }

    /**
     * Creates a set of 12 checker pieces with a given color.
     * @param color specifies the color to make the checker pieces.
     * @return List of the checker pieces of the specified color.
     */
    private List<Checker> createCheckerSet(Color color){
        List<Checker> checkerList = new ArrayList<>();
        for(int i = 0; i < Constants.CHECKER_COUNT; i++){
            Checker checker = new Checker(color, checkerID++);
            checker.addChangeListener(this);
            checkerList.add(i, checker);
        }
        checkerID = 0;  //reset checkerID for the next color
        return checkerList;
    }

    /**
     * Add all the squares to the physical generated board with swing.
     */
    private void addSquaresToBoard(){
        for(int row = 0; row < Constants.CHECKER_ROWS; row++){
            for(int column = 0; column < Constants.CHECKER_COLUMNS; column++){
                BoardSquare boardSquare = this.checkerBoard.getCheckerBoard()[row][column];
                boardSquare.addChangeListener(this);    //listen for square clicks.
                /*Update the params for the square*/
                boardSquare.added = true;
                checkerBoard.addSquareToBoard(boardSquare);
            }
        }
    }

    /**
     * Algorithm to place the checker pieces in their initial states on the board.
     * Top-Left is (0,0)
     * Bottom-Right is (7,7)
     * * * * * * * * * *
     * W _ W _ W _ W _ *
     * _ W _ W _ W _ W *
     * W _ W _ W _ W _ *
     * _ _ _ _ _ _ _ _ *
     * _ _ _ _ _ _ _ _ *
     * _ B _ B _ B _ B *
     * B _ B _ B _ B _ *
     * _ B _ B _ B _ B *
     * * * * * * * * * *
     *
     * 12 pieces of each color placed on a 8 x 8 game board.
     */
    private void setUpCheckerBoard(){
        int whiteCheckerCounter = 0;
        int blackCheckerCounter = 0;
        for(int row = 0; row < Constants.CHECKER_ROWS; row++){
            for(int column = 0; column < Constants.CHECKER_COLUMNS; column++){
                BoardSquare currentSquare = this.checkerBoard.getCheckerBoard()[row][column];
                switch(row){
                    case 0:
                    case 2:
                        if(column == 0 || column == 2 || column == 4 || column == 6){
                            addCheckerToSquare(Color.WHITE, whiteCheckerCounter, currentSquare);
                            whiteCheckerCounter++;
                        }
                        break;
                    case 1:
                        if(column == 1 || column == 3 || column == 5 || column == 7){
                            addCheckerToSquare(Color.WHITE, whiteCheckerCounter, currentSquare);
                            whiteCheckerCounter++;
                        }
                        break;
                    case 5:
                    case 7:
                        if(column == 1 || column == 3 || column == 5 || column == 7){
                            addCheckerToSquare(Color.BLACK, blackCheckerCounter, currentSquare);
                            blackCheckerCounter++;
                        }
                        break;
                    case 6:
                        if(column == 0 || column == 2 || column == 4 || column == 6){
                            addCheckerToSquare(Color.BLACK, blackCheckerCounter, currentSquare);
                            blackCheckerCounter++;
                        }
                        break;
                }
            }
        }
    }

    /**
     * Add a checker to a square.
     * Set the state of the square.
     * @param color color of the piece to add to square.
     * @param id identifier of the checker.
     * @param square square to add checker to.
     */
    private void addCheckerToSquare(Color color, int id, BoardSquare square){
        String checkerIdentifier = color.toString() + "_" + id;
        Checker checker = this.checkerMap.get(checkerIdentifier);
        checker.setCurrentSquare(square);
        addCheckerToSquare(square,checker);
    }

    /**
     * Move a selected checker from one square to another
     * based on what move is performed.
     * @param newSquare the square that is clicked on and
     *                  will be the new residence of the checker.
     */
    public void moveSelectedChecker(BoardSquare newSquare){
        for(String checkerKey: this.checkerMap.keySet()){
            Checker checker = this.checkerMap.get(checkerKey);
            if(checker.getClickedState().equals(ClickedState.CLICKED)){
                if(checker.getCheckerColor().equals(CheckerGame.PLAYER_TURN)) {
                    Move move = determineMove(checker.getCurrentSquare(), newSquare);
                    if (move != null) {
                        moveChecker(checkerKey, move);
                    }
                }
                checker.setClickedState(ClickedState.NOT_CLICKED);  //reset for next turn, atomic operation
                break;
            }
        }
        /*Reset the game board for the next turn.*/
        this.checkerBoard.resetBoardSquares();
        setAllCheckersToNotChecked(null);
    }

    /**
     * Change the color of the player whose turn it is,
     * based on the previous color.
     */
    private static Color changePlayerTurn(Color currentColor){
        switch(currentColor){
            case WHITE:
                return Color.BLACK;
            case BLACK:
                return Color.WHITE;
        }
        /*can never occur as only colors used are BLACK and WHITE*/
        return Color.WHITE; //return white so null pointer does not happen
    }

    /**
     * This method determines the move that is attempted
     * to be completed by analyzing the distance between the chosen square
     * and the square the the checker currently resides on. Checks are in place
     * to keep the player from moving too many spaces during a move. Valid moves
     * are those that increase the piece in one direction by any combination
     * of one column and one row or two columns and two rows.
     * @param previousSquare the square the checker piece is leaving.
     * @param nextSquare the square the checker piece wishes to go to.
     * @return the move that is generated from the distance jumped or moved
     *      from the previousSquare to the nextSquare.
     */
    private Move determineMove(BoardSquare previousSquare, BoardSquare nextSquare){
        Move currentMove = null;
        /*Get the location of the previous square.*/
        int prevRow = previousSquare.getRow();
        int prevColumn = previousSquare.getColumn();
        /*Get the location of the next square.*/
        int nextRow = nextSquare.getRow();
        int nextColumn = nextSquare.getColumn();
        /*Calculate the distance between the squares*/
        int rowDistance = Math.abs(prevRow - nextRow);
        int columnDistance = Math.abs(prevColumn - nextColumn);
        /*Normal move*/
        if(rowDistance == 1 && columnDistance == 1){
            //we have a valid selected square.
            if(nextRow > prevRow && nextColumn > prevColumn){//row + 1, column + 1
                currentMove = Move.FORWARD_LEFT;
            }else if(nextRow > prevRow && nextColumn < prevColumn){//row + 1, column - 1
                currentMove = Move.FORWARD_RIGHT;
            }else if(nextRow < prevRow && nextColumn > prevColumn){//row - 1, column + 1
                currentMove = Move.BACKWARD_LEFT;
            }else if(nextRow < prevRow && nextColumn < prevColumn){//row - 1, column - 1
                currentMove = Move.BACKWARD_RIGHT;
            }
        }
        /*Jump move*/
        else if(rowDistance == 2 && columnDistance == 2){
            if(nextRow > prevRow && nextColumn > prevColumn){//row + 2, column + 2
                currentMove = Move.FORWARD_JUMP_LEFT;
            }else if(nextRow > prevRow && nextColumn < prevColumn){//row + 2, column - 2
                currentMove = Move.FORWARD_JUMP_RIGHT;
            }else if(nextRow < prevRow && nextColumn > prevColumn){//row - 2, column + 2
                currentMove = Move.BACKWARD_JUMP_LEFT;
            }else if(nextRow < prevRow && nextColumn < prevColumn){//row - 2, column - 2
                currentMove = Move.BACKWARD_JUMP_RIGHT;
            }
            /*Verify that the jump is valid.*/
            if(!isJumpValid(previousSquare,currentMove)){
                return null;
            }
        }
        return currentMove;
    }

    /**
     * Procedure to move a checker from current position to a new location onto
     * the game board.
     * Assume the move is valid.
     * @param checkerID id of the checker piece to be moved.
     * @param move move taken by the checker.
     */
    private void moveChecker(String checkerID, Move move){
        Checker checker = this.checkerMap.get(checkerID);
        BoardSquare currentSquare = checker.getCurrentSquare();
        /*Short circuit by using a valid move check.*/
        if(!isValidDirectionOfMovement(currentSquare, move)){
            return;
        }
        BoardSquare nextSquare = nextBoardSquare(currentSquare, move);
        /*King promotion on movement of piece.*/
        String startRow = checker.getStartSide().toString();
        switch(startRow){
            case Constants.WHITE:
                if(nextSquare.getRow() == 7){
                    checker.promoteToKing();
                }
                break;
            case Constants.BLACK:
                if(nextSquare.getRow() == 0){
                    checker.promoteToKing();
                }
                break;
        }
        boolean jumpMade = false;
        if(this.jumpInvolved){
            BoardSquare preSquare = determinePreSquare(currentSquare, move);
            if(preSquare != null) {
                removeJumpedChecker(preSquare);
                jumpMade = true;
            }
            this.jumpInvolved = false;  //reset for next move
        }
        /*Change player turns if a valid movement was made.
        * Set current square if valid movement was made.
        * Set square occupancy if valid movement was made.*/
        if(isValidDirectionOfMovement(currentSquare, move)){
            removeCheckerFromSquare(currentSquare, checker);
            addCheckerToSquare(nextSquare,checker);
            /*Go to next player turn if another jump is not available*/
            boolean jumpAvailable = anotherJumpAvailable(checker);
            if(jumpMade && jumpAvailable) {
                //perform a double jump
                this.statusPanel.updateWinnerLabel(Constants.CURRENT_TURN + CheckerGame.PLAYER_TURN + Constants.DOUBLE_JUMP);
            }else{
                Color winner = isWinner();
                if (winner != null) {
                    this.statusPanel.updateWinnerLabel(Constants.WINNER + winner);
                    return;
                }
                CheckerGame.PLAYER_TURN = changePlayerTurn(CheckerGame.PLAYER_TURN);
                this.statusPanel.updateWinnerLabel(Constants.CURRENT_TURN + CheckerGame.PLAYER_TURN);
            }
            if(AI){
                allowComputerMove();
            }
        }
    }

    /**
     * Allow the computer to make a move.
     * Assume that AI is turned on.
     */
    private void allowComputerMove(){
        if(this.computerPlayer != null && CheckerGame.PLAYER_TURN.equals(this.computerPlayer.getComputerColor())){
            Thread computerPlayerMove = new Thread(new ComputerPlayerMove(this.computerPlayer));
            computerPlayerMove.start();
        }
    }

    /**
     * When a jump is made, it is important to determine the
     * square that is between the start point and the square
     * the checker will now reside on. This method
     * determines what square is between the two squares by
     * moving one square in the direction of the jump.
     * @param currentSquare the square the checker is leaving from.
     * @param movePerformed the move that was performed for the jump.
     * @return the board square that the jumped checker resides on.
     */
    private BoardSquare determinePreSquare(BoardSquare currentSquare, Move movePerformed){
        Move preMove = findPreMove(movePerformed);
        if(preMove == null){
            return null;
        }
        /*Short circuit the nextBoardSquare by returning current square if
        * not valid direction of motion.*/
        if(!isValidDirectionOfMovement(currentSquare, preMove)){
            return currentSquare;
        }
        return nextBoardSquare(currentSquare,preMove);
    }

    /**
     * Find the preliminary move made to achieve the
     * move that is given.
     * @param movePerformed the end result move to be made.
     * @return the preliminary move that is made prior to
     *          a jump.
     */
    private static Move findPreMove(Move movePerformed){
        Move preMove = null;
        switch(movePerformed){
            case FORWARD_JUMP_LEFT:
                preMove = Move.FORWARD_LEFT;
                break;
            case FORWARD_JUMP_RIGHT:
                preMove = Move.FORWARD_RIGHT;
                break;
            case BACKWARD_JUMP_LEFT:
                preMove = Move.BACKWARD_LEFT;
                break;
            case BACKWARD_JUMP_RIGHT:
                preMove = Move.BACKWARD_RIGHT;
                break;
        }
        return preMove;
    }

    /**
     * Remove a checker that has been jumped from the board.
     * This should only be called from the method for
     * moving checkers, as the flag for if the move
     * was a jump move is available there.
     * @param square the square that contains the checker
     *               that is to be removed.
     */
    private void removeJumpedChecker(BoardSquare square){
        Checker checker = getCheckerFromSquare(square);
        if(checker != null) {
            checker.setCaptured();
            System.out.println("Checker captured: "+checker.toString());
            removeCheckerFromSquare(square,checker);
        }
    }

    /**
     * Retrieve the checker located on a specific square.
     * @param square the square to be checked.
     * @return the checker that lies on the given square.
     */
    private Checker getCheckerFromSquare(BoardSquare square){
        if(!this.jumpInvolved) {
            /*If the square is vacant, there cannot be a checker there.*/
            if (square.getSquareState().equals(SquareState.VACANT)) {
                return null;
            }
        }
        /*Traverse the checker map and find the checker that is
        * in the specified square.*/
        for(Checker checker : this.checkerMap.values()){
            BoardSquare checkerSquare = checker.getCurrentSquare();
            if(checkerSquare != null && checkerSquare.equals(square)){
                return checker;
            }
        }
        return null;
    }

    /**
     * Determine if there is jump available for a specified checker.
     * @return if the specified checker has an available jump.
     */
    public ArrayList<BoardSquare> jumpAvailable(Checker checker){
        ArrayList<BoardSquare> jumpsAvailable = new ArrayList<>();
        BoardSquare checkerCurrentSquare = checker.getCurrentSquare();
        Object[][] possibleJumpSquares = possibleJumps(checkerCurrentSquare);
        for(Object[] possibleJump : possibleJumpSquares){
            if(possibleJump[0] != null && possibleJump[1] != null) {
                if (isJumpValid(checkerCurrentSquare, (Move) possibleJump[1])) {
                    jumpsAvailable.add((BoardSquare) possibleJump[0]);
                }
            }
        }
        return jumpsAvailable;
    }

    /**
     * Calculate all possible jumps for a given square.
     * Casting is required when checking the values.
     * @param square start square to calculate jumps from.
     * @return Object[][] of {[newSquare,move]*4}
     *      Moves that returned the same square are marked
     *      with null in the array.
     */
    private Object[][] possibleJumps(BoardSquare square){
        BoardSquare possibleForwardLeft = nextBoardSquare(square, Move.FORWARD_JUMP_LEFT);
        if(possibleForwardLeft.equals(square)){
            possibleForwardLeft = null;
        }
        BoardSquare possibleForwardRight = nextBoardSquare(square, Move.FORWARD_JUMP_RIGHT);
        if(possibleForwardRight.equals(square)){
            possibleForwardRight = null;
        }
        BoardSquare possibleBackwardLeft = nextBoardSquare(square, Move.BACKWARD_JUMP_LEFT);
        if(possibleBackwardLeft.equals(square)){
            possibleBackwardLeft = null;
        }
        BoardSquare possibleBackwardRight = nextBoardSquare(square, Move.BACKWARD_JUMP_RIGHT);
        if(possibleBackwardRight.equals(square)){
            possibleBackwardRight = null;
        }
        Move[] possibleMoves = new Move[] {Move.FORWARD_JUMP_LEFT, Move.FORWARD_JUMP_RIGHT, Move.BACKWARD_JUMP_LEFT, Move.BACKWARD_JUMP_RIGHT};
        BoardSquare[] possibleNewSquares = new BoardSquare[] {possibleForwardLeft, possibleForwardRight, possibleBackwardLeft, possibleBackwardRight};
        Object[][] possibleJumps = new Object[4][2];
        for(int i = 0; i < possibleJumps.length; i++){
            possibleJumps[i][0] = possibleNewSquares[i];
            possibleJumps[i][1] = possibleMoves[i];
        }
        return possibleJumps;
    }

    /**
     * To determine if a jump is valid, the following items must be met:
     *      Square to jump to must be vacant.
     *      Square jumping over must be occupied with opponent colored piece.
     * @param currentSquare the square of where the current player piece
     *               is residing.
     * @param jumpMove the move that is being performed.
     * @return true if the jump is valid and can be performed,
     *          false if the jump is invalid and cannot be performed.
     */
    private boolean isJumpValid(BoardSquare currentSquare, Move jumpMove){
        Color opponentPlayerColor = changePlayerTurn(CheckerGame.PLAYER_TURN);
        /*Short circuit the nextBoardSquare by returning current square if
        * not valid direction of motion.*/
        if(!isValidDirectionOfMovement(currentSquare, jumpMove)){
            return false;
        }
        BoardSquare nextSquare = nextBoardSquare(currentSquare, jumpMove);
        if(nextSquare.getSquareState().equals(SquareState.VACANT)){
            BoardSquare preSquare = determinePreSquare(currentSquare,jumpMove);
            if(preSquare == null){
                return false;   //should never occur, due to boundaries of clickable squares
            }
            Checker opponentChecker = getCheckerFromSquare(preSquare);
            if(opponentChecker == null){
                return false;   //should never occur as the square is occupied.
            }
            if(opponentChecker.getCheckerColor().equals(opponentPlayerColor)){
                return true;    //valid jump move found.
            }
        }
        return false;
    }

    /**
     * Determine if there is move available for a specified checker.
     * @return if the specified checker has an available move.
     */
    public ArrayList<BoardSquare> moveAvailable(Checker checker){
        ArrayList<BoardSquare> movesAvailable = new ArrayList<>();
        BoardSquare checkerCurrentSquare = checker.getCurrentSquare();
        Object[][] possibleMoveSquares = possibleMoves(checkerCurrentSquare);
        for(Object[] possibleMove : possibleMoveSquares){
            if(possibleMove[0] != null && possibleMove[1] != null) {
                if (isMoveValid(checkerCurrentSquare, (Move) possibleMove[1])) {
                    movesAvailable.add((BoardSquare) possibleMove[0]);
                }
            }
        }
        return movesAvailable;
    }

    /**
     * Calculate all possible moves for a given square.
     * Casting is required when checking the values.
     * @param square start square to calculate moves from.
     * @return Object[][] of {[newSquare,move]*4}
     *      Moves that returned the same square are marked
     *      with null in the array.
     */
    private Object[][] possibleMoves(BoardSquare square){
        BoardSquare possibleForwardLeft = nextBoardSquare(square, Move.FORWARD_LEFT);
        if(possibleForwardLeft.equals(square)){
            possibleForwardLeft = null;
        }
        BoardSquare possibleForwardRight = nextBoardSquare(square, Move.FORWARD_RIGHT);
        if(possibleForwardRight.equals(square)){
            possibleForwardRight = null;
        }
        BoardSquare possibleBackwardLeft = nextBoardSquare(square, Move.BACKWARD_LEFT);
        if(possibleBackwardLeft.equals(square)){
            possibleBackwardLeft = null;
        }
        BoardSquare possibleBackwardRight = nextBoardSquare(square, Move.BACKWARD_RIGHT);
        if(possibleBackwardRight.equals(square)){
            possibleBackwardRight = null;
        }
        Move[] moves = new Move[] {Move.FORWARD_LEFT, Move.FORWARD_RIGHT, Move.BACKWARD_LEFT, Move.BACKWARD_RIGHT};
        BoardSquare[] possibleNewSquares = new BoardSquare[] {possibleForwardLeft, possibleForwardRight, possibleBackwardLeft, possibleBackwardRight};
        Object[][] possibleMoves = new Object[4][2];
        for(int i = 0; i < possibleMoves.length; i++){
            possibleMoves[i][0] = possibleNewSquares[i];
            possibleMoves[i][1] = moves[i];
        }
        return possibleMoves;
    }

    /**
     * Determine if the given move can be achieved from the given square.
     * @param currentSquare current square the checker resides on.
     * @param normalMove normal single square move to make.
     * @return true if the move is valid, false if the move cannot be made.
     */
    private boolean isMoveValid(BoardSquare currentSquare, Move normalMove) {
        /*Short circuit the nextBoardSquare by returning current square if
        * not valid direction of motion.*/
        if (!isValidDirectionOfMovement(currentSquare, normalMove)) {
            return false;
        }
        BoardSquare nextSquare = nextBoardSquare(currentSquare, normalMove);
        return (!nextSquare.equals(currentSquare) && nextSquare.getSquareState().equals(SquareState.VACANT));
    }

    /**
     * Retrieves the next board square based off of the move.
     * If the move results in an invalid move, return the original
     * board square.
     * @param currentSquare old board square
     * @param move requested move to be done
     * @return new board square for the checker location
     */
    private BoardSquare nextBoardSquare(BoardSquare currentSquare, Move move){
        int row = currentSquare.getRow();
        int column = currentSquare.getColumn();
        int[] rowCol = getRowColNextSquare(row,column,move);
        row = rowCol[0];
        column = rowCol[1];

        /*If the new square would fall outside the checker board.
        * return the original square.*/
        if(row < 0 || row > 7 || column < 0 || column > 7){
            return currentSquare;
        }

        /*Return the board space at the row and column.*/
        return this.checkerBoard.getCheckerBoard()[row][column];
    }

    /**
     * Determine if the move from a given square follows the correct direction
     * of movement based on what type of piece the checker is.
     * @param square the square the checker resides on.
     * @param move the move to be performed from the given square.
     * @return true if the move is in the correct direction,
     *          false if the move is invalid.
     */
    private boolean isValidDirectionOfMovement(BoardSquare square, Move move){
        Checker checker = getCheckerFromSquare(square);
        if(checker == null){
            return false;
        }
        if(CheckerGame.PLAYER_TURN.equals(Color.BLACK)){
            if(checker.getCheckerPiece().equals(Piece.STANDARD)){
                switch(move){
                    case BACKWARD_JUMP_LEFT:
                    case BACKWARD_JUMP_RIGHT:
                    case BACKWARD_LEFT:
                    case BACKWARD_RIGHT:
                        return true;
                }
            }else if(checker.getCheckerPiece().equals(Piece.KING)){
                return true;
            }
        }else if(CheckerGame.PLAYER_TURN.equals(Color.WHITE)){
            if(checker.getCheckerPiece().equals(Piece.STANDARD)){
                switch(move){
                    case FORWARD_JUMP_LEFT:
                    case FORWARD_JUMP_RIGHT:
                    case FORWARD_LEFT:
                    case FORWARD_RIGHT:
                        return true;
                }
            }else if(checker.getCheckerPiece().equals(Piece.KING)){
                return true;
            }
        }
        return false;
    }

    /**
     * Get the row and column of the next square based on
     * the move that is being performed.
     * @param row the row of the current square.
     * @param column the column of the current square.
     * @param move the move that is to be performed.
     * @return int[] of {row,column} of where the next square should be.
     */
    private int[] getRowColNextSquare(int row, int column, Move move){
        switch(move){
            case FORWARD_RIGHT:
                row += 1;
                column -= 1;
                break;
            case FORWARD_LEFT:
                row += 1;
                column += 1;
                break;
            case BACKWARD_RIGHT:
                row -= 1;
                column -= 1;
                break;
            case BACKWARD_LEFT:
                row -= 1;
                column += 1;
                break;
            case FORWARD_JUMP_RIGHT:
                row += 2;
                column -= 2;
                this.jumpInvolved = true;
                break;
            case FORWARD_JUMP_LEFT:
                row += 2;
                column += 2;
                this.jumpInvolved = true;
                break;
            case BACKWARD_JUMP_RIGHT:
                row -= 2;
                column -= 2;
                this.jumpInvolved = true;
                break;
            case BACKWARD_JUMP_LEFT:
                row -= 2;
                column += 2;
                this.jumpInvolved = true;
                break;
        }
        return new int[]{row,column};
    }

    /**
     * Reset all checkers to not be checked when a checker
     * is checked. CLICKED and NOT_CLICKED should be atomic.
     * @param checkedChecker checker that has been checked.
     */
    private void setAllCheckersToNotChecked(Checker checkedChecker){
        for(Checker checker : this.checkerMap.values()){
            if(checkedChecker != null && checker.equals(checkedChecker)){
                continue;
            }
            checker.setClickedState(ClickedState.NOT_CLICKED);
        }
    }

    /**
     * Remove a checker from a specific square.
     * Set the parameters on the square and checker
     * before executing the GUI updates. This allows
     * for the AI or another player to make a move
     * even if the GUI is not updated.
     * @param boardSquare Square that is removing a checker.
     * @param checker Checker to be removed from a square.
     */
    private void removeCheckerFromSquare(BoardSquare boardSquare, Checker checker){
        System.out.println("Removing "+checker.toString()+" from "+boardSquare.toString());
        boardSquare.removeCheckerFromSquare(checker);
    }

    /**
     * Add a checker to a specific square.
     * Set the parameters on the square and checker
     * before executing the GUI updates. This allows
     * for the AI or another player to make a move
     * even if the GUI is not updated.
     * @param boardSquare Square that is adding a checker.
     * @param checker Checker to be added to a square.
     */
    private void addCheckerToSquare(BoardSquare boardSquare, Checker checker){
        System.out.println("Adding "+checker.toString()+" to "+boardSquare.toString());
        boardSquare.addCheckerToSquare(checker);
    }

    /**
     * Determine if a winner has occurred.
     * @return Color of winner, or null if no winner has been determined.
     */
    private Color isWinner(){
        int remainingWhite = 0;
        int remainingBlack = 0;
        /*Search through all checkers to determine how many are
        * remaining for a given color.*/
        for(Checker checker : this.checkerMap.values()){
            /*If the current square is null, this checker is no longer
            * in play.*/
            if(checker.getCurrentSquare() != null) {
                if (checker.getCheckerColor().equals(Color.WHITE)) {
                    remainingWhite++;
                } else if (checker.getCheckerColor().equals(Color.BLACK)) {
                    remainingBlack++;
                }
            }
        }
        /*Update the GUI for new remaining pieces.*/
        this.statusPanel.updateRemainingPieces(Constants.WHITE_PIECES_REMAIN+remainingWhite,Color.WHITE);
        this.statusPanel.updateRemainingPieces(Constants.BLACK_PIECES_REMAIN+remainingBlack,Color.BLACK);

        if(remainingBlack == 0){
            return Color.BLACK;
        }
        if(remainingWhite == 0){
            return Color.WHITE;
        }
        return null;
    }

    /**
     * Determine if there is another jump available for
     * a given checker.
     * @param checker Checker that could have another jump.
     * @return true if another jump is available, false otherwise.
     */
    private boolean anotherJumpAvailable(Checker checker){
        return jumpAvailable(checker).size() > 0;
    }
}
